<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mukden's Karun map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/OverlappingMarkerSpiderfier-Leaflet/0.2.6/oms.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-groupedlayercontrol/0.6.1/leaflet.groupedlayercontrol.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-groupedlayercontrol/0.6.1/leaflet.groupedlayercontrol.min.js"></script>

  <link rel="stylesheet" href="./css/site.css" />

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }

    /* Top nav */
    .topnav{
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 44px;
      display: flex;
      gap: 48px;
      align-items: center;
      padding: 0 80px;
      background: rgba(255,255,255,0.95);
      z-index: 1000;
      border-bottom: 1px solid #ddd;
    }
    .topnav a{ text-decoration:none; color:#111; font-weight:600; }

/* lv1, lv2: 아이콘 */
.admin-dot{
  width: 6px; height: 6px; 
  border-radius: 50%;
  background: #004eff; 
  border: 0; 
  box-shadow: none; 
}
    
    /* 삼각형 라벨 */
    .tri {
  width: 14px;
  height: 14px;
  background: var(--tri, #d62728);
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  border: 1px solid rgba(0,0,0,0.75);
  box-sizing: border-box;
  filter: drop-shadow(0 1px 1px rgba(255,255,255,0.8));
}
    
#map{
  width: 100%;
  height: calc(100% - 44px);
  margin-top: 44px;
}

    /* Tooltip labels */
    .leaflet-tooltip.plain-label{
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
      margin: 0;
      color: #000;
      font-size: 13px;
      font-weight: 600;
      text-shadow: 0 0 2px #fff, 0 0 2px #fff;
    }
    .leaflet-tooltip.plain-label:before{ display: none !important; }

    /* Make layers control scroll internally (not whole page) */
    .leaflet-control-layers{
      max-height: calc(100vh - 60px);
      overflow: hidden;
    }
    .leaflet-control-layers-overlays{
      max-height: calc(100vh - 140px);
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 6px;
    }
.leaflet-control-layers-group-name{
  font-size: 14px;
  font-weight: 900;
  letter-spacing: 0.2px;
  margin-top: 10px;
  margin-bottom: 6px; 
}
    
.info-panel{
  position: fixed;
  top: 44px;
  left: 0;        
  right: auto;    
  width: 360px;
  height: calc(100vh - 44px);
  background: rgba(255,255,255,0.98);
  border-right: 1px solid #ddd; 
  border-left: none;
  z-index: 1200;
  display: flex;
  flex-direction: column;
  box-shadow: 6px 0 20px rgba(0,0,0,0.08); 
}

.info-panel.hidden{ display:none; }

.info-head{
  display:flex;
  align-items:center;
  justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid #eee;
}
.info-title{ font-weight: 800; }
.info-close{
  font-size: 22px;
  line-height: 22px;
  border: none;
  background: transparent;
  cursor: pointer;
}

.info-body{
  padding: 10px 12px;
  overflow: auto;
  font-size: 13px;
}

.info-body table{ width:100%; border-collapse: collapse; }
.info-body th{ text-align:left; padding:4px 8px 4px 0; white-space:nowrap; vertical-align: top; }
.info-body td{ padding:4px 0; word-break: break-word; }
     
  </style>
</head>

<body>
  <nav class="topnav">
    <a href="https://mucenfere.github.io/">Home</a>
    <a href="./index.html">Map</a>
    <a href="./gazetteer.html">Gazetteer</a>
    <a href="./reference.html">Reference</a>
    <a href="./lop.html">Work Log</a>
  </nav>

  <div id="map"></div>
  <div id="infoPanel" class="info-panel hidden">
  <div class="info-head">
    <div id="infoTitle" class="info-title">정보</div>
    <button id="infoClose" class="info-close" type="button">×</button>
  </div>
  <div id="infoBody" class="info-body"></div>
</div>

  <script>
    const map = L.map('map').setView([42, 126], 7);
    const mkDivIcon = (className, size) => L.divIcon({
  className: '',
  html: `<div class="${className}"></div>`,
  iconSize: [size, size],
  iconAnchor: [size/2, size/2],
  popupAnchor: [0, -size/2]
});
const oms = new OverlappingMarkerSpiderfier(map, {
  keepSpiderfied: true,  
  nearbyDistance: 20,    
  legWeight: 1.2
});
    
    
const icon_admin = mkDivIcon('admin-dot', 10);
    
const panel = document.getElementById('infoPanel');
L.DomEvent.disableClickPropagation(panel);
L.DomEvent.disableScrollPropagation(panel);
const infoTitleEl = document.getElementById('infoTitle');
const infoBodyEl  = document.getElementById('infoBody');
const infoCloseEl = document.getElementById('infoClose');

function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, (m)=>({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
  }[m]));
}

function openInfoPanel(title, props){
  infoTitleEl.textContent = title || '정보';

  const rows = Object.entries(props || {})
    .map(([k,v]) => `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(v)}</td></tr>`)
    .join('');

  infoBodyEl.innerHTML = `<table>${rows}</table>`;

  panel.classList.remove('hidden');
}
function closeInfoPanel(){
  panel.classList.add('hidden');
}
    if (infoCloseEl) infoCloseEl.addEventListener('click', closeInfoPanel);
    
    // Basemaps
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    });

    const satellite = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri' }
    );

    const labels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri', opacity: 0.5 }
    );

    satellite.addTo(map);
      const baseLayers = {
        "위성": satellite, 
        "OSM": osm
      };

    // Styles
    const willowpalisade = { color: '#d60000', weight: 2, opacity: 1 };

async function loadGeoJSON(url, options = {}) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to fetch ${url} (HTTP ${res.status})`);
  const gj = await res.json();

  return L.geoJSON(gj, {
    style: options.style,
    pointToLayer: options.pointToLayer,
    onEachFeature: (feature, layer) => {
      const p = feature.properties || {};
      const labelText = p.name_chf || p.name || p.NAME_FT || '정보';

      if (options.label === true) {
        layer.bindTooltip(labelText, {
          permanent: true,
          direction: 'top',
          offset: [0, -6],
          opacity: 1,
          className: 'plain-label'
        });
      }

      layer.on('click', () => openInfoPanel(labelText, p));
    }
  });
}
    (async () => {

      //카룬
async function fetchGeoJSON(url){
     const res = await fetch(url);
     if (!res.ok) throw new Error(`Failed to fetch ${url} (HTTP ${res.status})`);
     return await res.json();
     }
    const karunAll = await fetchGeoJSON('./data/karun_all.geojson');
      
      // 국경선 백색 라인
      const bordersWhite = await loadGeoJSON('./data/borders.geojson', {
          style: { color: '#ffffff', weight: 1.8, opacity: 0.5 }
       });
      const bordersLayer = L.layerGroup([bordersWhite]).addTo(map);
      
      // CHGIS
      const chgisprov_pgn = await loadGeoJSON('./data/v6_1820_prov_pgn.geojson', { style: { weight: 2, fillOpacity: 0.1 }});
      const chgispref_pgn = await loadGeoJSON('./data/v6_1820_pref_pgn.geojson', { style: { weight: 2, fillOpacity: 0.1 }});
      const chgispref_pts = await loadGeoJSON('./data/v6_1820_pref_pts.geojson', { 
                label: true,
        pointToLayer: (f, latlng) => L.circleMarker(latlng, {
          radius: 2,
          color: '#000000',
          weight: 1,
          fillColor: '#000000',
          fillOpacity: 1
        })
      });
        const chgistwn_pts = await loadGeoJSON('./data/v6_1820_twn_pts.geojson', {
        label: true,
        pointToLayer: (f, latlng) => L.circleMarker(latlng, {
          radius: 2,
          color: '#000000',
          weight: 1,
          fillColor: '#000000',
          fillOpacity: 1
        })
      });

      //icon

const icon_wp_gate = L.icon({
  iconUrl: './data/img/willowgateicon.png',
  iconSize: [10, 10],
  iconAnchor: [9, 9],
  popupAnchor: [0, -9]
});
const icon_giyamun = L.icon({
  iconUrl: './data/img/giyamunicon.png',
  iconSize: [10, 10],
  iconAnchor: [9, 9],
  popupAnchor: [0, -9]
});   

//카룬의 필터
function zoneType(zoneStr){
  const z = String(zoneStr || '').toLowerCase();
  if (z.includes('변대') || z.includes(' tai')) return 'tai';
  if (z.includes('변내') || z.includes('dorgi')) return 'dorgi';
  if (z.includes('변외') || z.includes('tulergi')) return 'tulergi';
  if (z.includes('위장') || z.includes('aba')) return 'aba';
  return 'unknown';
}

// Triangle icon factory (no PNG)
const mkTriIcon = (color, size = 10) => L.divIcon({
  className: '', // Leaflet
  html: `<div class="tri" style="--tri:${color}; width:${size}px; height:${size}px;"></div>`,
  iconSize: [size, size],
  iconAnchor: [size / 2, size / 2], 
  popupAnchor: [0, -size / 2]
});

// GeoJSON point options using triangle marker
const mkTriPt = (color, { size = 10, label = false } = {}) => ({
  label,
  pointToLayer: (f, latlng) => L.marker(latlng, { icon: mkTriIcon(color, size) })
});
function makeKarunLayer(gj, { time, ztype, color }) {
  return L.geoJSON(gj, {
    filter: (f) => {
      const p = f.properties || {};
      return p.time === time && zoneType(p.zone) === ztype;
    },
    pointToLayer: mkTriPt(color).pointToLayer,
    onEachFeature: (feature, layer) => {
      const p = feature.properties || {};
      const labelText = p.name_chf || p.NAME_FT || '정보';
      layer.bindTooltip(labelText, {
        permanent: true,
        direction: 'top',
        offset: [0, -6],
        opacity: 1,
        className: 'plain-label'
      });

      if (typeof openInfoPanel === 'function') {
        layer.on('click', () => openInfoPanel(labelText, p));
      }
    }
  });
}
      
  const mkIconPt = (icon, { label = false } = {}) => ({
    label,
    pointToLayer: (f, latlng) => L.marker(latlng, { icon })
  });
      
// 카룬 아이콘 색깔
const dk_KX = '#00A2FF'; // 밝은 스카이블루
const tk_KX = '#FFD400'; // 밝은 옐로(블루 보색)

const dk_YZ = '#B000FF'; // 선명 퍼플
const tk_YZ = '#7CFF00'; // 라임 그린(퍼플 보색)

const dk_QL = '#00E676'; // 밝은 그린(민트 계열)
const tk_QL = '#FF4DFF'; // 밝은 마젠타(그린 보색)

const dk_JQ = '#FF8C00'; // 밝은 오렌지(빨강 아님)
const tk_JQ = '#00E5FF'; // 밝은 시안(오렌지 대비)
      
const JQWC  = '#005CFF'; // 코발트 블루(시안/오렌지와 구분, 위성에서 강함)

const dk_DG = '#6A00FF'; // 진한 바이올렛(퍼플 계열이지만 YZ보다 더 푸른 톤)
const tk_DG = '#FFF000'; // 네온 옐로(바이올렛 보색, 빨강 아님)


// 강희: 변대(tai) + 변외(tulergi)
const kx_tai     = makeKarunLayer(karunAll, { time: '강희말기', ztype: 'tai',     color: dk_KX });
const kx_tulergi = makeKarunLayer(karunAll, { time: '강희말기', ztype: 'tulergi', color: tk_KX });
const karun_kx_bundle = L.layerGroup([kx_tai, kx_tulergi]);
karun_kx_bundle.addTo(map)
      
// 옹정: 변내(dorgi) + 변외(tulergi)
const yz_dorgi   = makeKarunLayer(karunAll, { time: '옹정초기', ztype: 'dorgi',   color: dk_YZ });
const yz_tulergi = makeKarunLayer(karunAll, { time: '옹정초기', ztype: 'tulergi', color: tk_YZ });
const karun_yz_bundle = L.layerGroup([yz_dorgi, yz_tulergi]);

// 건륭
const ql_dorgi   = makeKarunLayer(karunAll, { time: '건륭중기', ztype: 'dorgi',   color: dk_QL });
const ql_tulergi = makeKarunLayer(karunAll, { time: '건륭중기', ztype: 'tulergi', color: tk_QL });
const karun_ql_bundle = L.layerGroup([ql_dorgi, ql_tulergi]);

// 가경
const jq_dorgi   = makeKarunLayer(karunAll, { time: '가경9년', ztype: 'dorgi',   color: dk_JQ });
const jq_tulergi = makeKarunLayer(karunAll, { time: '가경9년', ztype: 'tulergi', color: tk_JQ });
const karun_jq_bundle = L.layerGroup([jq_dorgi, jq_tulergi]);

// 가경위장
const jq_weichang   = makeKarunLayer(karunAll, { time: '가경23년', ztype: 'aba',   color: JQWC });

// 도광
const dg_dorgi   = makeKarunLayer(karunAll, { time: '도광27년', ztype: 'dorgi',   color: dk_DG });
const dg_tulergi = makeKarunLayer(karunAll, { time: '도광27년', ztype: 'tulergi', color: tk_DG });
const karun_dg_bundle = L.layerGroup([dg_dorgi, dg_tulergi]);
      
// 성경장군 경계선
const admin_v1 = await loadGeoJSON('./data/admin_lv1_line.geojson', {
        style: { color: '#000000', weight: 4, opacity: 0.8 }
      });
      admin_v1.addTo(map);
const admin_pts = await loadGeoJSON('./data/manchu_admin_pt.geojson', {
  label: true,
  pointToLayer: (feature, latlng) => {
    const marker = L.marker(latlng, { icon: icon_admin });
    oms.addMarker(marker);                                
    return marker;
  }
});
      const giyamun_pt = await loadGeoJSON('./data/manchu_giyamun_pt.geojson',
      mkIconPt(icon_giyamun, { label: false })
      );
      
      const wpkangxi = await loadGeoJSON('./data/willowpalisade-kangxi.geojson', { style: willowpalisade });
      const wp_gate_kx_pts = await loadGeoJSON('./data/willowpalisade_gate_kxyz.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpkangxi_bundle = L.layerGroup([wpkangxi, wp_gate_kx_pts]);
      wpkangxi_bundle.addTo(map)
      
      const wpqianlong = await loadGeoJSON('./data/willowpalisade-qianlong.geojson', { style: willowpalisade });
      const wp_gate_ql_pts = await loadGeoJSON('./data/willowpalisade_gate_ql.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpqianlong_bundle = L.layerGroup([wpqianlong, wp_gate_ql_pts]);
      
      const groupedOverlays = {
        "기본지리정보": { "성경장군 관할 경계선": admin_v1, "행정 지명(lv1/lv2)": admin_pts, "역참": giyamun_pt },
        "유조변": { "유조변(강희-옹정)": wpkangxi_bundle, "유조변(건륭이후)": wpqianlong_bundle },
        "강희기 카룬": { "邊臺/카룬(강희말기)": karun_kx_bundle },
        "옹정기 카룬": { "변내/변외카룬(옹정초기)": karun_yz_bundle },
        "건륭기 카룬": { "변내/변외카룬(건륭중기)": karun_ql_bundle },
        "가경기 카룬": { "변내/변외카룬(가경 9년)": karun_jq_bundle },
        "가경기 위장카룬": { "성경위장 카룬(가경 23년)": jq_weichang },
        "도광기 카룬": { "변내/변외카룬(도광 27년)": karun_dg_bundle },
        "참고자료_CHGIS (1820)": { "省 경계선(1820_CHGIS)": chgisprov_pgn, "府 경계선(1820_CHGIS)": chgispref_pgn, "府 치소(1820_CHGIS)": chgispref_pts, "지명(1820_CHGIS)": chgistwn_pts}
      };

L.control.groupedLayers(baseLayers, groupedOverlays, {
  collapsed: false,
  groupsCollapsible: false,
  groupCheckboxes: false
}).addTo(map);

    })().catch(err => {
      console.error(err);
      alert(err.message || err);
    });
  </script>
</body>
</html>
