<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mukden's Karun map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/OverlappingMarkerSpiderfier-Leaflet/0.2.6/oms.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-groupedlayercontrol/0.6.1/leaflet.groupedlayercontrol.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-groupedlayercontrol/0.6.1/leaflet.groupedlayercontrol.min.js"></script>

  <link rel="stylesheet" href="./css/site.css" />

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }

    /* Top nav */
    .topnav{
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 44px;
      display: flex;
      gap: 48px;
      align-items: center;
      padding: 0 80px;
      background: rgba(255,255,255,0.95);
      z-index: 1000;
      border-bottom: 1px solid #ddd;
    }
    .topnav a{ text-decoration:none; color:#111; font-weight:600; }

/* lv1, lv2: 아이콘 */
.admin-dot{
  width: 10px; height: 10px; 
  border-radius: 50%;
  background: #3388ff; 
  border: 2px solid #ffffff; 
  box-sizing: border-box;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.35); 
}
    
    /* 삼각형 라벨 */
    .tri {
  width: 12px;
  height: 12px;
  background: var(--tri, #d62728);
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  border: 1px solid rgba(0,0,0,0.75);
  box-sizing: border-box;
  filter: drop-shadow(0 1px 1px rgba(255,255,255,0.8));
}
    
#map{
  width: 100%;
  height: calc(100% - 44px);
  margin-top: 44px;
}

    /* Tooltip labels */
    .leaflet-tooltip.plain-label{
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
      margin: 0;
      color: #000;
      font-size: 15px;
      font-weight: 700;
      text-shadow: 0 0 2px #fff, 0 0 2px #fff;
    }
    .leaflet-tooltip.plain-label:before{ display: none !important; }

    /* Make layers control scroll internally (not whole page) */
    .leaflet-control-layers{
      max-height: calc(100vh - 60px);
      overflow: hidden;
    }
    .leaflet-control-layers-overlays{
      max-height: calc(100vh - 140px);
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 6px;
    }
.leaflet-control-layers-group-name{
  font-size: 14px;
  font-weight: 900;
  letter-spacing: 0.2px;
  margin-top: 10px;
  margin-bottom: 6px; 
}
    
.info-panel{
  position: fixed;
  top: 44px;
  left: 0;        
  right: auto;    
  width: 360px;
  height: calc(100vh - 44px);
  background: rgba(255,255,255,0.98);
  border-right: 1px solid #ddd; 
  border-left: none;
  z-index: 1200;
  display: flex;
  flex-direction: column;
  box-shadow: 6px 0 20px rgba(0,0,0,0.08); 
}

.info-panel.hidden{ display:none; }

.info-head{
  display:flex;
  align-items:center;
  justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid #eee;
}
.info-title{ font-weight: 800; }
.info-close{
  font-size: 22px;
  line-height: 22px;
  border: none;
  background: transparent;
  cursor: pointer;
}

.info-body{
  padding: 10px 12px;
  overflow: auto;
  font-size: 13px;
}

.info-body table{ width:100%; border-collapse: collapse; }
.info-body th{ text-align:left; padding:4px 8px 4px 0; white-space:nowrap; vertical-align: top; }
.info-body td{ padding:4px 0; word-break: break-word; }
     
  </style>
</head>

<body>
  <nav class="topnav">
    <a href="https://mucenfere.github.io/">Home</a>
    <a href="./index.html">Map</a>
    <a href="./gazetteer.html">Gazetteer</a>
    <a href="./reference.html">Reference</a>
    <a href="./lop.html">Work Log</a>
  </nav>

  <div id="map"></div>
  <div id="infoPanel" class="info-panel hidden">
  <div class="info-head">
    <div id="infoTitle" class="info-title">정보</div>
    <button id="infoClose" class="info-close" type="button">×</button>
  </div>
  <div id="infoBody" class="info-body"></div>
</div>

  <script>
    const map = L.map('map').setView([42, 126], 7);
    const mkDivIcon = (className, size) => L.divIcon({
  className: '',
  html: `<div class="${className}"></div>`,
  iconSize: [size, size],
  iconAnchor: [size/2, size/2],
  popupAnchor: [0, -size/2]
});
const oms = new OverlappingMarkerSpiderfier(map, {
  keepSpiderfied: true,   // 펼친 상태 유지(원하면 false)
  nearbyDistance: 20,     // 겹침 판정 민감도(원하면 조절)
  legWeight: 1.2
});
    
    
const icon_admin = mkDivIcon('admin-dot', 10);
    
const panel = document.getElementById('infoPanel');
L.DomEvent.disableClickPropagation(panel);
L.DomEvent.disableScrollPropagation(panel);
const infoTitleEl = document.getElementById('infoTitle');
const infoBodyEl  = document.getElementById('infoBody');
const infoCloseEl = document.getElementById('infoClose');

function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, (m)=>({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
  }[m]));
}

function openInfoPanel(title, props){
  infoTitleEl.textContent = title || '정보';

  const rows = Object.entries(props || {})
    .map(([k,v]) => `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(v)}</td></tr>`)
    .join('');

  infoBodyEl.innerHTML = `<table>${rows}</table>`;

  panel.classList.remove('hidden');
}
function closeInfoPanel(){
  panel.classList.add('hidden');
}
    if (infoCloseEl) infoCloseEl.addEventListener('click', closeInfoPanel);
    
    // Basemaps
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    });

    const satellite = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri' }
    );

    const labels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri', opacity: 0.5 }
    );

    const satelliteWithLabels = L.layerGroup([satellite, labels]).addTo(map);

    const baseLayers = {
      "위성": satelliteWithLabels,
      "OSM": osm
    };

    // Styles
    const willowpalisade = { color: '#d60000', weight: 2, opacity: 1 };

async function loadGeoJSON(url, options = {}) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to fetch ${url} (HTTP ${res.status})`);
  const gj = await res.json();

  return L.geoJSON(gj, {
    style: options.style,
    pointToLayer: options.pointToLayer,
    onEachFeature: (feature, layer) => {
      const p = feature.properties || {};
      const labelText = p.name || p.name_chf || '정보';

      if (options.label === true) {
        layer.bindTooltip(labelText, {
          permanent: true,
          direction: 'top',
          offset: [0, -6],
          opacity: 1,
          className: 'plain-label'
        });
      }

      layer.on('click', () => openInfoPanel(labelText, p));
    }
  });
}
    (async () => {
      // CHGIS
      const chgisprov_pgn = await loadGeoJSON('./data/v6_1820_prov_pgn.geojson', { style: { weight: 2, fillOpacity: 0.1 }});
      const chgispref_pgn = await loadGeoJSON('./data/v6_1820_pref_pgn.geojson', { style: { weight: 2, fillOpacity: 0.1 }});
      const chgispref_pts = await loadGeoJSON('./data/v6_1820_pref_pts.geojson', { 
                label: true,
        pointToLayer: (f, latlng) => L.circleMarker(latlng, {
          radius: 2,
          color: '#000000',
          weight: 1,
          fillColor: '#000000',
          fillOpacity: 1
        })
      });
        const chgistwn_pts = await loadGeoJSON('./data/v6_1820_twn_pts.geojson', {
        label: true,
        pointToLayer: (f, latlng) => L.circleMarker(latlng, {
          radius: 2,
          color: '#000000',
          weight: 1,
          fillColor: '#000000',
          fillOpacity: 1
        })
      });

      //icon

const icon_wp_gate = L.icon({
  iconUrl: './data/img/willowgateicon.png',
  iconSize: [10, 10],
  iconAnchor: [9, 9],
  popupAnchor: [0, -9]
});
const icon_giyamun = L.icon({
  iconUrl: './data/img/giyamunicon.png',
  iconSize: [10, 10],
  iconAnchor: [9, 9],
  popupAnchor: [0, -9]
});   
      
// Triangle icon factory (no PNG)
const mkTriIcon = (color, size = 14) => L.divIcon({
  className: '', // Leaflet
  html: `<div class="tri" style="--tri:${color}; width:${size}px; height:${size}px;"></div>`,
  iconSize: [size, size],
  iconAnchor: [size / 2, size / 2], 
  popupAnchor: [0, -size / 2]
});

// GeoJSON point options using triangle marker
const mkTriPt = (color, { size = 14, label = false } = {}) => ({
  label,
  pointToLayer: (f, latlng) => L.marker(latlng, { icon: mkTriIcon(color, size) })
});
      const mkIconPt = (icon, { label = false } = {}) => ({
  label,
  pointToLayer: (f, latlng) => L.marker(latlng, { icon })
});
      
const KX = '#004eff';
const YZ = '#ff7f0e';
const QL = '#2ca02c';
const JQ = '#d62728';

// dorgi
const dk_kx = await loadGeoJSON('./data/dorgi_karun_kangxi.geojson', mkTriPt(KX));
const dk_yz = await loadGeoJSON('./data/dorgi_karun_yongzheng.geojson', mkTriPt(YZ));
const dk_ql = await loadGeoJSON('./data/dorgi_karun_qianlong.geojson', mkTriPt(QL));
const dk_jq = await loadGeoJSON('./data/dorgi_karun_jiaqing.geojson', mkTriPt(JQ));

// tulergi
const tk_kx = await loadGeoJSON('./data/tulergi_karun_kangxi.geojson', mkTriPt(KX));
const tk_yz = await loadGeoJSON('./data/tulergi_karun_yongzheng.geojson', mkTriPt(YZ));
const tk_ql = await loadGeoJSON('./data/tulergi_karun_qianlong.geojson', mkTriPt(QL));
const tk_jq = await loadGeoJSON('./data/tulergi_karun_jiaqing.geojson', mkTriPt(JQ));
      
      const admin_v1 = await loadGeoJSON('./data/admin_lv1_line.geojson', {
        style: { color: '#000000', weight: 4, opacity: 0.8 }
      });
      admin_v1.addTo(map);
const admin_pts = await loadGeoJSON('./data/manchu_admin_pt.geojson', {
  label: true,
  pointToLayer: (feature, latlng) => {
    const marker = L.marker(latlng, { icon: icon_admin });
    oms.addMarker(marker);                                
    return marker;
  }
});
      const giyamun_pt = await loadGeoJSON('./data/manchu_giyamun_pt.geojson',
      mkIconPt(icon_giyamun, { label: false })
      );
      const wpkangxi = await loadGeoJSON('./data/willowpalisade-kangxi.geojson', { style: willowpalisade });
      const wp_gate_kx_pts = await loadGeoJSON('./data/willowpalisade_gate_kxyz.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpkangxi_bundle = L.layerGroup([wpkangxi, wp_gate_kx_pts]);
      
      const wpyongzheng = await loadGeoJSON('./data/willowpalisade-kangxi.geojson', { style: willowpalisade });
      const wp_gate_yz_pts = await loadGeoJSON('./data/willowpalisade_gate_kxyz.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpyongzheng_bundle = L.layerGroup([wpyongzheng, wp_gate_yz_pts]);
      
      const wpqianlong = await loadGeoJSON('./data/willowpalisade-qianlong.geojson', { style: willowpalisade });
      const wp_gate_ql_pts = await loadGeoJSON('./data/willowpalisade_gate_ql.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpqianlong_bundle = L.layerGroup([wpqianlong, wp_gate_ql_pts]);
      
      const wpjiaqing = await loadGeoJSON('./data/willowpalisade-qianlong.geojson', { style: willowpalisade });
      const wp_gate_jq_pts = await loadGeoJSON('./data/willowpalisade-gate-qianlong.geojson',
      mkIconPt(icon_wp_gate, { label: false })
      );
      const wpjiaqing_bundle = L.layerGroup([wpjiaqing, wp_gate_jq_pts]);
        
      const groupedOverlays = {
        "기본지리정보": { "성경장군 관할 경계선": admin_v1, "행정 지명(lv1/lv2)": admin_pts, "역참": giyamun_pt },
        "강희기 카룬": { "유조변(강희-옹정)": wpkangxi_bundle, "邊臺(강희기)": dk_kx, "변외카룬(강희기)": tk_kx },
        "옹정기 카룬": { "유조변(강희-옹정)": wpyongzheng_bundle, "변내카룬(옹정기)": dk_yz, "변외카룬(옹정기)": tk_yz },
        "건륭기 카룬": { "유조변(건륭이후)": wpqianlong_bundle, "변내카룬(건륭기)": dk_ql, "변외카룬(건륭기)": tk_ql },
        "가경기 카룬": { "유조변(건륭이후)": wpjiaqing_bundle, "변내카룬(가경기)": dk_jq, "변외카룬(가경기)": tk_jq },
        "참고자료_CHGIS (1820)": { "省 경계선(1820_CHGIS)": chgisprov_pgn, "府 경계선(1820_CHGIS)": chgispref_pgn, "府 치소(1820_CHGIS)": chgispref_pts, "지명(1820_CHGIS)": chgistwn_pts}
      };

L.control.groupedLayers(baseLayers, groupedOverlays, {
  collapsed: false,
  groupsCollapsible: false,
  groupCheckboxes: false
}).addTo(map);

    })().catch(err => {
      console.error(err);
      alert(err.message || err);
    });
  </script>
</body>
</html>
